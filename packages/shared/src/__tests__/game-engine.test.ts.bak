// @ts-nocheck
/**
 * Tests for game engine and state management
 */

import { beforeEach, describe, expect, it } from 'vitest';
import { Card, Rank, Suit } from '../types/card';
import { GamePhase, GameState, PlayerRanking } from '../types/game';
import { SeatPosition, Team } from '../types/room';
import {
  arePartners,
  canResistTribute,
  determineTributeRequirements,
  getFinishedPlayers,
  getNextPlayer,
  getNextSeat,
  getPartnerSeat,
  getRemainingCards,
  hasPlayerFinished,
  passPlay,
  playCards,
  shouldEndGame,
  startNewTurn,
} from '../utils/game-engine';

// Helper to create a card
function createCard(rank: Rank, suit: Suit, id?: string): Card {
  return {
    id: id || `${suit}-${rank}-${Math.random()}`,
    rank,
    suit,
    isRedHeart: suit === Suit.HEARTS,
  };
}

// Helper to create a basic game state
function createGameState(overrides?: Partial<GameState>): GameState {
  return {
    gameId: 'test-game',
    roomId: 'test-room',
    currentRank: Rank.TWO,
    phase: GamePhase.PLAYING,
    seats: [
      { playerId: 'player1', position: SeatPosition.NORTH, team: Team.NS },
      { playerId: 'player2', position: SeatPosition.EAST, team: Team.EW },
      { playerId: 'player3', position: SeatPosition.SOUTH, team: Team.NS },
      { playerId: 'player4', position: SeatPosition.WEST, team: Team.EW },
    ],
    playerHands: {
      player1: [
        createCard(Rank.KING, Suit.SPADES),
        createCard(Rank.QUEEN, Suit.HEARTS),
      ],
      player2: [
        createCard(Rank.JACK, Suit.CLUBS),
        createCard(Rank.TEN, Suit.DIAMONDS),
      ],
      player3: [
        createCard(Rank.NINE, Suit.SPADES),
        createCard(Rank.EIGHT, Suit.HEARTS),
      ],
      player4: [
        createCard(Rank.SEVEN, Suit.CLUBS),
        createCard(Rank.SIX, Suit.DIAMONDS),
      ],
    },
    currentTurn: {
      turnNumber: 1,
      currentPlayerId: 'player1',
      lastPlayerId: null,
      lastPlay: null,
      passCount: 0,
      passes: [],
    },
    rankings: [
      { playerId: 'player1', rank: 0, finishedAt: 0 },
      { playerId: 'player2', rank: 0, finishedAt: 0 },
      { playerId: 'player3', rank: 0, finishedAt: 0 },
      { playerId: 'player4', rank: 0, finishedAt: 0 },
    ],
    turnNumber: 1,
    startedAt: Date.now(),
    ...overrides,
  };
}

describe('Seat and Partner Logic', () => {
  it('should get next seat clockwise', () => {
    expect(getNextSeat(SeatPosition.NORTH)).toBe(SeatPosition.EAST);
    expect(getNextSeat(SeatPosition.EAST)).toBe(SeatPosition.SOUTH);
    expect(getNextSeat(SeatPosition.SOUTH)).toBe(SeatPosition.WEST);
    expect(getNextSeat(SeatPosition.WEST)).toBe(SeatPosition.NORTH);
  });

  it('should get partner seat', () => {
    expect(getPartnerSeat(SeatPosition.NORTH)).toBe(SeatPosition.SOUTH);
    expect(getPartnerSeat(SeatPosition.SOUTH)).toBe(SeatPosition.NORTH);
    expect(getPartnerSeat(SeatPosition.EAST)).toBe(SeatPosition.WEST);
    expect(getPartnerSeat(SeatPosition.WEST)).toBe(SeatPosition.EAST);
  });

  it('should check if players are partners', () => {
    expect(arePartners(SeatPosition.NORTH, SeatPosition.SOUTH)).toBe(true);
    expect(arePartners(SeatPosition.EAST, SeatPosition.WEST)).toBe(true);
    expect(arePartners(SeatPosition.NORTH, SeatPosition.EAST)).toBe(false);
    expect(arePartners(SeatPosition.SOUTH, SeatPosition.WEST)).toBe(false);
  });
});

describe('Player State Checks', () => {
  let state: GameState;

  beforeEach(() => {
    state = createGameState();
  });

  it('should get remaining card count', () => {
    expect(getRemainingCards(state, 'player1')).toBe(2);
    expect(getRemainingCards(state, 'player2')).toBe(2);
  });

  it('should detect finished player', () => {
    expect(hasPlayerFinished(state, 'player1')).toBe(false);

    const finishedState = createGameState({
      playerHands: { ...state.playerHands, player1: [] },
    });
    expect(hasPlayerFinished(finishedState, 'player1')).toBe(true);
  });

  it('should get finished players in order', () => {
    const stateWithFinished = createGameState({
      rankings: [
        { playerId: 'player1', rank: 1, finishedAt: 1000 },
        { playerId: 'player2', rank: 2, finishedAt: 2000 },
        { playerId: 'player3', rank: 0, finishedAt: 0 },
        { playerId: 'player4', rank: 0, finishedAt: 0 },
      ],
    });

    const finished = getFinishedPlayers(stateWithFinished);
    expect(finished).toEqual(['player1', 'player2']);
  });

  it('should detect game end when 3 players finished', () => {
    const stateWithThreeFinished = createGameState({
      rankings: [
        { playerId: 'player1', rank: 1, finishedAt: 1000 },
        { playerId: 'player2', rank: 2, finishedAt: 2000 },
        { playerId: 'player3', rank: 3, finishedAt: 3000 },
        { playerId: 'player4', rank: 0, finishedAt: 0 },
      ],
    });

    expect(shouldEndGame(stateWithThreeFinished)).toBe(true);
    expect(shouldEndGame(state)).toBe(false);
  });
});

describe('Turn Management', () => {
  let state: GameState;

  beforeEach(() => {
    state = createGameState();
  });

  it('should start new turn', () => {
    const newTurn = startNewTurn(state, 'player2');

    expect(newTurn.currentPlayerId).toBe('player2');
    expect(newTurn.turnNumber).toBe(2);
    expect(newTurn.lastPlay).toBeNull();
    expect(newTurn.passCount).toBe(0);
  });

  it('should get next player in turn order', () => {
    const nextPlayer = getNextPlayer(state);
    expect(nextPlayer).toBe('player2'); // Next after player1 (NORTH -> EAST)
  });

  it('should skip finished players', () => {
    const stateWithFinished = createGameState({
      playerHands: {
        ...state.playerHands,
        player2: [], // player2 finished
      },
    });

    const nextPlayer = getNextPlayer(stateWithFinished);
    expect(nextPlayer).toBe('player3'); // Skip player2, go to player3
  });

  it('should let last player play again after 3 passes', () => {
    const stateAfterPasses = createGameState({
      currentTurn: {
        turnNumber: 1,
        currentPlayerId: 'player1',
        lastPlayerId: 'player1',
        lastPlay: [createCard(Rank.KING, Suit.SPADES)],
        passCount: 3,
        passes: ['player2', 'player3', 'player4'],
      },
    });

    const nextPlayer = getNextPlayer(stateAfterPasses);
    expect(nextPlayer).toBe('player1'); // Same player plays again
  });
});

describe('Play Cards Action', () => {
  let state: GameState;

  beforeEach(() => {
    state = createGameState();
  });

  it('should successfully play cards on first turn', () => {
    const cards = [
      createCard(Rank.KING, Suit.SPADES, state.playerHands.player1[0].id),
    ];
    const result = playCards(state, { playerId: 'player1', cards });

    expect(result.success).toBe(true);
    expect(result.state?.currentTurn?.lastPlay).toEqual(cards);
    expect(result.state?.currentTurn?.currentPlayerId).toBe('player2');
    expect(result.events).toHaveLength(1);
    expect(result.events?.[0].type).toBe('CARDS_PLAYED');
  });

  it('should reject play when not player turn', () => {
    const cards = [
      createCard(Rank.JACK, Suit.CLUBS, state.playerHands.player2[0].id),
    ];
    const result = playCards(state, { playerId: 'player2', cards });

    expect(result.success).toBe(false);
    expect(result.error).toBe('Not your turn');
  });

  it('should reject play with invalid cards', () => {
    const cards = [createCard(Rank.ACE, Suit.SPADES, 'nonexistent-id')];
    const result = playCards(state, { playerId: 'player1', cards });

    expect(result.success).toBe(false);
    expect(result.error).toBe('Invalid cards');
  });

  it('should detect player finishing', () => {
    const stateWithOneCard = createGameState({
      playerHands: {
        ...state.playerHands,
        player1: [createCard(Rank.KING, Suit.SPADES, 'king-1')],
      },
    });

    const cards = [createCard(Rank.KING, Suit.SPADES, 'king-1')];
    const result = playCards(stateWithOneCard, { playerId: 'player1', cards });

    expect(result.success).toBe(true);
    expect(result.events).toHaveLength(2);
    expect(result.events?.[1].type).toBe('PLAYER_FINISHED');
    expect(
      result.state?.rankings.find((r) => r.playerId === 'player1')?.rank
    ).toBe(1);
  });

  it('should transition to ending phase when 3 players finish', () => {
    const stateWithTwoFinished = createGameState({
      playerHands: {
        player1: [createCard(Rank.KING, Suit.SPADES, 'king-1')],
        player2: [],
        player3: [],
        player4: [createCard(Rank.SEVEN, Suit.CLUBS)],
      },
      rankings: [
        { playerId: 'player1', rank: 0, finishedAt: 0 },
        { playerId: 'player2', rank: 1, finishedAt: 1000 },
        { playerId: 'player3', rank: 2, finishedAt: 2000 },
        { playerId: 'player4', rank: 0, finishedAt: 0 },
      ],
    });

    const cards = [createCard(Rank.KING, Suit.SPADES, 'king-1')];
    const result = playCards(stateWithTwoFinished, {
      playerId: 'player1',
      cards,
    });

    expect(result.success).toBe(true);
    expect(result.state?.phase).toBe(GamePhase.ENDING);
  });
});

describe('Pass Action', () => {
  let state: GameState;

  beforeEach(() => {
    state = createGameState({
      currentTurn: {
        turnNumber: 1,
        currentPlayerId: 'player2',
        lastPlayerId: 'player1',
        lastPlay: [createCard(Rank.KING, Suit.SPADES)],
        passCount: 0,
        passes: [],
      },
    });
  });

  it('should successfully pass', () => {
    const result = passPlay(state, 'player2');

    expect(result.success).toBe(true);
    expect(result.state?.currentTurn?.passCount).toBe(1);
    expect(result.state?.currentTurn?.passes).toContain('player2');
    expect(result.state?.currentTurn?.currentPlayerId).toBe('player3');
  });

  it('should reject pass when not player turn', () => {
    const result = passPlay(state, 'player1');

    expect(result.success).toBe(false);
    expect(result.error).toBe('Not your turn');
  });

  it('should reject pass when no previous play', () => {
    const stateFirstPlay = createGameState({
      currentTurn: {
        turnNumber: 1,
        currentPlayerId: 'player1',
        lastPlayerId: null,
        lastPlay: null,
        passCount: 0,
        passes: [],
      },
    });

    const result = passPlay(stateFirstPlay, 'player1');

    expect(result.success).toBe(false);
    expect(result.error).toBe('Cannot pass as first player');
  });

  it('should reset round after 3 passes', () => {
    const stateAfterTwoPasses = createGameState({
      currentTurn: {
        turnNumber: 1,
        currentPlayerId: 'player4',
        lastPlayerId: 'player1',
        lastPlay: [createCard(Rank.KING, Suit.SPADES)],
        passCount: 2,
        passes: ['player2', 'player3'],
      },
    });

    const result = passPlay(stateAfterTwoPasses, 'player4');

    expect(result.success).toBe(true);
    expect(result.state?.currentTurn?.passCount).toBe(0);
    expect(result.state?.currentTurn?.lastPlay).toBeNull();
    expect(result.state?.currentTurn?.currentPlayerId).toBe('player1'); // Winner plays again
  });
});

describe('Tribute System', () => {
  it('should detect double down tribute requirement', () => {
    const rankings: PlayerRanking[] = [
      { playerId: 'player1', rank: 1, finishedAt: 1000 },
      { playerId: 'player2', rank: 2, finishedAt: 2000 },
      { playerId: 'player3', rank: 3, finishedAt: 3000 },
      { playerId: 'player4', rank: 4, finishedAt: 4000 },
    ];

    const result = determineTributeRequirements(rankings);

    expect(result.tributeRequired).toBe(true);
    expect(result.tributeType).toBe('double');
    expect(result.tributePairs).toHaveLength(2);
  });

  it('should detect single down tribute requirement', () => {
    const rankings: PlayerRanking[] = [
      { playerId: 'player1', rank: 1, finishedAt: 1000 },
      { playerId: 'player2', rank: 2, finishedAt: 2000 },
      { playerId: 'player3', rank: 3, finishedAt: 3000 },
      { playerId: 'player4', rank: 4, finishedAt: 4000 },
    ];

    // Adjust to simulate single down (would need proper seat mapping in real impl)
    rankings[1].rank = 4; // Make second player lose
    rankings[3].rank = 2; // Make fourth player win

    const result = determineTributeRequirements(rankings);

    // In simplified version, this tests the logic structure
    expect(result).toBeDefined();
  });

  it('should detect tribute resistance with two big jokers', () => {
    const hand = [
      createCard(Rank.BIG_JOKER, Suit.JOKER),
      createCard(Rank.BIG_JOKER, Suit.JOKER),
      createCard(Rank.KING, Suit.SPADES),
    ];

    expect(canResistTribute(hand)).toBe(true);
  });

  it('should not allow resistance with one big joker', () => {
    const hand = [
      createCard(Rank.BIG_JOKER, Suit.JOKER),
      createCard(Rank.SMALL_JOKER, Suit.JOKER),
      createCard(Rank.KING, Suit.SPADES),
    ];

    expect(canResistTribute(hand)).toBe(false);
  });
});
