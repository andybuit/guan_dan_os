/**
 * Game State Management for Guandan
 * Handles game flow, turn management, and state transitions
 */

import { Card, Rank } from '../types/card';
import { GamePhase, GameState, PlayerRanking, Turn } from '../types/game';
import { SeatPosition } from '../types/room';
import { isLegalPlay } from './card-comparator';

/**
 * Game action types
 */
export enum GameAction {
  START_GAME = 'START_GAME',
  PLAY_CARDS = 'PLAY_CARDS',
  PASS = 'PASS',
  TRIBUTE = 'TRIBUTE',
  RETURN_TRIBUTE = 'RETURN_TRIBUTE',
  FINISH_PLAYER = 'FINISH_PLAYER',
  END_GAME = 'END_GAME',
}

/**
 * Action payload for playing cards
 */
export interface PlayCardsPayload {
  playerId: string;
  cards: Card[];
}

/**
 * Action payload for tribute
 */
export interface TributePayload {
  fromPlayerId: string;
  toPlayerId: string;
  card: Card;
}

/**
 * Result of a game action
 */
export interface ActionResult {
  success: boolean;
  error?: string;
  state?: GameState;
  events?: GameEvent[];
}

/**
 * Game events for real-time updates
 */
export interface GameEvent {
  type: string;
  data: any;
  timestamp: number;
}

/**
 * Get next player in turn order (clockwise)
 */
export function getNextSeat(current: SeatPosition): SeatPosition {
  const order = [
    SeatPosition.NORTH,
    SeatPosition.EAST,
    SeatPosition.SOUTH,
    SeatPosition.WEST,
  ];
  const currentIndex = order.indexOf(current);
  return order[(currentIndex + 1) % 4];
}

/**
 * Get partner's seat position
 */
export function getPartnerSeat(seat: SeatPosition): SeatPosition {
  switch (seat) {
    case SeatPosition.NORTH:
      return SeatPosition.SOUTH;
    case SeatPosition.SOUTH:
      return SeatPosition.NORTH;
    case SeatPosition.EAST:
      return SeatPosition.WEST;
    case SeatPosition.WEST:
      return SeatPosition.EAST;
  }
}

/**
 * Check if two seats are partners (same team)
 */
export function arePartners(seat1: SeatPosition, seat2: SeatPosition): boolean {
  return getPartnerSeat(seat1) === seat2;
}

/**
 * Get player's remaining card count
 */
export function getRemainingCards(state: GameState, playerId: string): number {
  return state.hands[playerId]?.cards?.length || 0;
}

/**
 * Check if player has finished (no cards left)
 */
export function hasPlayerFinished(state: GameState, playerId: string): boolean {
  return getRemainingCards(state, playerId) === 0;
}

/**
 * Get players who have finished, in order
 */
export function getFinishedPlayers(state: GameState): string[] {
  if (!state.roundResults || state.roundResults.length === 0) {
    return [];
  }
  
  const currentRound = state.roundResults[state.roundResults.length - 1];
  return currentRound.rankings
    .sort((a, b) => {
      const rankOrder = { FIRST: 1, SECOND: 2, THIRD: 3, LAST: 4 };
      return rankOrder[a.ranking] - rankOrder[b.ranking];
    })
    .map(r => r.playerId);
}

/**
 * Check if game should end (3 players finished)
 */
export function shouldEndGame(state: GameState): boolean {
  return getFinishedPlayers(state).length >= 3;
}

/**
 * Detect 接风 (windfall) - partner gets next turn after winning play
 *
 * Conditions:
 * 1. Current player just played their last card(s)
 * 2. No one can beat it (all others passed)
 * 3. Partner gets next turn (out of normal order)
 */
export function detectWindfall(
  state: GameState,
  playerId: string
): string | null {
  // Player must have just finished
  if (!hasPlayerFinished(state, playerId)) {
    return null;
  }

  // All other active players must have passed
  const activePlayers = state.seats.filter(
    (s) => !hasPlayerFinished(state, s.playerId)
  );
  if (activePlayers.length === 0) {
    return null;
  }

  // Get partner's seat
  const playerSeat = state.seats.find((s) => s.playerId === playerId)?.position;
  if (!playerSeat) {
    return null;
  }

  const partnerSeat = getPartnerSeat(playerSeat);
  const partner = state.seats.find((s) => s.position === partnerSeat);

  // Partner must still be playing
  if (!partner || hasPlayerFinished(state, partner.playerId)) {
    return null;
  }

  return partner.playerId;
}

/**
 * Get next player to play
 * Handles normal turn order and windfall detection
 */
export function getNextPlayer(state: GameState): string | null {
  const currentTurn = state.currentTurn;
  if (!currentTurn) {
    return null;
  }

  // Check for windfall after player finishes
  if (
    currentTurn.lastPlayerId &&
    hasPlayerFinished(state, currentTurn.lastPlayerId)
  ) {
    const windfallPlayer = detectWindfall(state, currentTurn.lastPlayerId);
    if (windfallPlayer) {
      return windfallPlayer;
    }
  }

  // If current player won the round (no one beat them), they play again
  if (currentTurn.passCount >= 3 && currentTurn.lastPlayerId) {
    return currentTurn.lastPlayerId;
  }

  // Normal turn order
  const currentSeat = state.seats.find(
    (s) => s.playerId === currentTurn.currentPlayerId
  )?.position;
  if (!currentSeat) {
    return null;
  }

  let nextSeat = getNextSeat(currentSeat);
  let iterations = 0;

  // Find next active player (skip finished players)
  while (iterations < 4) {
    const nextPlayer = state.seats.find((s) => s.position === nextSeat);
    if (nextPlayer && !hasPlayerFinished(state, nextPlayer.playerId)) {
      return nextPlayer.playerId;
    }
    nextSeat = getNextSeat(nextSeat);
    iterations++;
  }

  return null;
}

/**
 * Start a new turn
 */
export function startNewTurn(state: GameState, startingPlayerId: string): Turn {
  return {
    turnNumber: state.turnNumber + 1,
    currentPlayerId: startingPlayerId,
    lastPlayerId: null,
    lastPlay: null,
    passCount: 0,
    passes: [],
  };
}

/**
 * Validate and execute PLAY_CARDS action
 */
export function playCards(
  state: GameState,
  payload: PlayCardsPayload
): ActionResult {
  const { playerId, cards } = payload;
  const turn = state.currentTurn;

  if (!turn) {
    return { success: false, error: 'No active turn' };
  }

  // Must be player's turn
  if (turn.currentPlayerId !== playerId) {
    return { success: false, error: 'Not your turn' };
  }

  // Player must have these cards
  const playerHand = state.playerHands[playerId] || [];
  const cardIds = cards.map((c) => c.id);
  const hasAllCards = cardIds.every((id) =>
    playerHand.some((c) => c.id === id)
  );

  if (!hasAllCards) {
    return { success: false, error: 'Invalid cards' };
  }

  // Validate play is legal
  const isFirstPlay = !turn.lastPlay || turn.passCount >= 3;
  const legalCheck = isLegalPlay(
    cards,
    isFirstPlay ? null : turn.lastPlay,
    state.currentRank,
    isFirstPlay
  );

  if (!legalCheck.canBeat) {
    return { success: false, error: legalCheck.reason || 'Illegal play' };
  }

  // Remove cards from hand
  const newHand = playerHand.filter((c) => !cardIds.includes(c.id));
  const newHands = { ...state.playerHands, [playerId]: newHand };

  // Update turn
  const newTurn: Turn = {
    ...turn,
    lastPlayerId: playerId,
    lastPlay: cards,
    passCount: 0,
    passes: [],
  };

  // Check if player finished
  const playerFinished = newHand.length === 0;
  const finishedCount = getFinishedPlayers(state).length;
  let newRankings = [...state.rankings];

  if (playerFinished) {
    newRankings = newRankings.map((r) =>
      r.playerId === playerId
        ? { ...r, rank: finishedCount + 1, finishedAt: Date.now() }
        : r
    );
  }

  // Get next player
  const nextPlayerId = getNextPlayer({
    ...state,
    currentTurn: newTurn,
    playerHands: newHands,
    rankings: newRankings,
  });

  if (!nextPlayerId) {
    return { success: false, error: 'Cannot determine next player' };
  }

  const newState: GameState = {
    ...state,
    playerHands: newHands,
    currentTurn: { ...newTurn, currentPlayerId: nextPlayerId },
    rankings: newRankings,
    turnNumber: state.turnNumber + 1,
  };

  // Check if game should end
  if (shouldEndGame(newState)) {
    newState.phase = GamePhase.ENDING;
  }

  const events: GameEvent[] = [
    {
      type: 'CARDS_PLAYED',
      data: { playerId, cards, playerFinished },
      timestamp: Date.now(),
    },
  ];

  if (playerFinished) {
    events.push({
      type: 'PLAYER_FINISHED',
      data: { playerId, rank: finishedCount + 1 },
      timestamp: Date.now(),
    });
  }

  return { success: true, state: newState, events };
}

/**
 * Validate and execute PASS action
 */
export function passPlay(state: GameState, playerId: string): ActionResult {
  const turn = state.currentTurn;

  if (!turn) {
    return { success: false, error: 'No active turn' };
  }

  // Must be player's turn
  if (turn.currentPlayerId !== playerId) {
    return { success: false, error: 'Not your turn' };
  }

  // Cannot pass if you're first to play (or round is reset)
  if (!turn.lastPlay || turn.passCount >= 3) {
    return { success: false, error: 'Cannot pass as first player' };
  }

  // Update turn with pass
  const newTurn: Turn = {
    ...turn,
    passCount: turn.passCount + 1,
    passes: [...turn.passes, playerId],
  };

  // Get next player
  const nextPlayerId = getNextPlayer({
    ...state,
    currentTurn: newTurn,
  });

  if (!nextPlayerId) {
    return { success: false, error: 'Cannot determine next player' };
  }

  // If 3 passes, last player wins and plays again (reset round)
  if (newTurn.passCount >= 3) {
    newTurn.lastPlay = null;
    newTurn.passCount = 0;
    newTurn.passes = [];
  }

  const newState: GameState = {
    ...state,
    currentTurn: { ...newTurn, currentPlayerId: nextPlayerId },
  };

  const events: GameEvent[] = [
    {
      type: 'PLAYER_PASSED',
      data: { playerId },
      timestamp: Date.now(),
    },
  ];

  return { success: true, state: newState, events };
}

/**
 * Calculate final rankings and rewards
 */
export function calculateFinalRankings(state: GameState): PlayerRanking[] {
  const rankings = [...state.rankings].sort((a, b) => a.rank - b.rank);

  // Assign remaining rank to unfinished player
  const finishedRanks = new Set(
    rankings.filter((r) => r.finishedAt > 0).map((r) => r.rank)
  );
  const remainingRank = [1, 2, 3, 4].find((r) => !finishedRanks.has(r)) || 4;

  return rankings.map((r) =>
    r.finishedAt > 0 ? r : { ...r, rank: remainingRank, finishedAt: Date.now() }
  );
}

/**
 * Determine tribute requirements based on rankings
 *
 * Returns:
 * - 双下 (double down): both losers pay tribute
 * - 单下 (single down): one loser pays tribute
 * - null: no tribute needed
 */
export function determineTributeRequirements(rankings: PlayerRanking[]): {
  tributeRequired: boolean;
  tributeType: 'double' | 'single' | null;
  tributePairs: Array<{ from: string; to: string }>;
} {
  const sorted = [...rankings].sort((a, b) => a.rank - b.rank);

  // Get ranks 1-4
  const first = sorted[0];
  const second = sorted[1];
  const third = sorted[2];
  const fourth = sorted[3];

  // Check if partners won both first and second (or first and third)
  const firstSeat = first.playerId; // Would need seat position mapping
  const secondSeat = second.playerId;

  // Simplified: Check by rank positions
  // 双下: Winners are 1st and 2nd, losers are 3rd and 4th
  const isDoubleDown = first.rank === 1 && second.rank === 2;

  if (isDoubleDown) {
    return {
      tributeRequired: true,
      tributeType: 'double',
      tributePairs: [
        { from: fourth.playerId, to: first.playerId },
        { from: third.playerId, to: second.playerId },
      ],
    };
  }

  // 单下: Winners are 1st and 3rd, one loser is 4th
  const isSingleDown = first.rank === 1 && third.rank === 3;

  if (isSingleDown) {
    return {
      tributeRequired: true,
      tributeType: 'single',
      tributePairs: [{ from: fourth.playerId, to: first.playerId }],
    };
  }

  return {
    tributeRequired: false,
    tributeType: null,
    tributePairs: [],
  };
}

/**
 * Check if player can resist tribute (抗贡) with two big jokers
 */
export function canResistTribute(hand: Card[]): boolean {
  const bigJokers = hand.filter((c) => c.rank === Rank.BIG_JOKER);
  return bigJokers.length >= 2;
}
